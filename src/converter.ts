import type { Transcript, ConversationTurn } from "./types.js";

/**
 * Convert a transcript to Notion-flavored markdown
 */
export function convertToNotionMarkdown(transcript: Transcript): string {
  const parts: string[] = [];

  // Add summary placeholder - this will be generated by the AI
  parts.push("## Summary\n");
  parts.push("<!-- Summary will be generated by the AI -->\n");
  parts.push("---\n");

  // Convert each turn
  for (const turn of transcript.turns) {
    parts.push(formatTurn(turn));
    parts.push("\n---\n");
  }

  return parts.join("\n");
}

/**
 * Format a single conversation turn
 */
function formatTurn(turn: ConversationTurn): string {
  const header = turn.role === "user" ? "### User" : "### Assistant";
  const content = formatContent(turn.content);

  return `${header}\n\n${content}`;
}

/**
 * Format content, preserving code blocks and adding proper formatting
 */
function formatContent(content: string): string {
  // Split content by code blocks to preserve them
  const codeBlockRegex = /```([^\n`]*)\n([\s\S]*?)```/g;
  let result = content;

  // Ensure code blocks have language hints where possible
  result = result.replace(codeBlockRegex, (match, lang, code) => {
    const normalizedLang = typeof lang === "string" ? lang.trim() : "";
    const language = normalizedLang || inferLanguage(code);
    return `\`\`\`${language}\n${code}\`\`\``;
  });

  return result;
}

/**
 * Try to infer the programming language from code content
 */
function inferLanguage(code: string): string {
  const trimmed = code.trim();

  if (trimmed.startsWith("{") && trimmed.endsWith("}")) {
    return "json";
  }
  if (trimmed.startsWith("<") && trimmed.endsWith(">")) {
    return "html";
  }
  if (trimmed.startsWith("$") || trimmed.includes("&&") || trimmed.includes("| ")) {
    return "bash";
  }
  // Python often starts with `import ...` / `from ... import ...`, which we should not misclassify as JS.
  if (
    /^def\s+\w+\s*\(/m.test(trimmed) ||
    /^class\s+\w+\s*[:(]/m.test(trimmed) ||
    /^from\s+\w[\w.]*\s+import\s+/m.test(trimmed) ||
    /^import\s+\w/m.test(trimmed) ||
    /\bprint\(/.test(trimmed) ||
    /\bself\b/.test(trimmed)
  ) {
    return "python";
  }
  if (
    /^\s*export\s+/m.test(trimmed) ||
    /^\s*import\s+/m.test(trimmed) ||
    /\binterface\s+\w+/.test(trimmed) ||
    /\btype\s+\w+\s*=/.test(trimmed) ||
    /\bimplements\s+\w+/.test(trimmed) ||
    /\breadonly\b/.test(trimmed) ||
    /\bas\s+const\b/.test(trimmed)
  ) {
    // Heuristic: assume TS if we see typical TS-only syntax (type/interface/readonly),
    // otherwise fall back to JS for ES module code.
    return /\b(interface|type|readonly)\b/.test(trimmed) || /:\s*\w+/.test(trimmed)
      ? "typescript"
      : "javascript";
  }

  return "";
}

/**
 * Parse raw transcript text into structured format
 */
export function parseTranscript(raw: string): Transcript {
  const turns: ConversationTurn[] = [];

  // Supports both `User: ...` / `Assistant: ...` and markdown headings like `### User`.
  // Anything before the first recognized marker is ignored.
  const lines = raw.replace(/\r\n/g, "\n").split("\n");

  let currentRole: ConversationTurn["role"] | undefined;
  let currentLines: string[] = [];

  const flush = () => {
    if (!currentRole) return;
    const content = currentLines.join("\n").trim();
    if (!content) return;
    turns.push({ role: currentRole, content });
  };

  const roleFromLabel = (label: string): ConversationTurn["role"] | undefined => {
    if (/^(user|human)$/i.test(label)) return "user";
    if (/^(assistant|claude)$/i.test(label)) return "assistant";
    return undefined;
  };

  for (const line of lines) {
    const colonMatch = /^(User|Human|Assistant|Claude)\s*:\s*(.*)$/i.exec(line);
    const headingMatch = /^#{2,6}\s*(User|Human|Assistant|Claude)\s*:?\s*$/i.exec(line.trim());

    if (colonMatch) {
      const role = roleFromLabel(colonMatch[1]);
      if (role) {
        flush();
        currentRole = role;
        currentLines = [];
        const inline = colonMatch[2];
        if (inline) currentLines.push(inline);
        continue;
      }
    }

    if (headingMatch) {
      const role = roleFromLabel(headingMatch[1]);
      if (role) {
        flush();
        currentRole = role;
        currentLines = [];
        continue;
      }
    }

    if (currentRole) currentLines.push(line);
  }

  flush();

  return { turns };
}

/**
 * Generate a title from the transcript content
 */
export function generateTitle(transcript: Transcript): string {
  const firstUserTurn = transcript.turns.find((t) => t.role === "user");
  if (!firstUserTurn) return "Untitled Conversation";

  // Take first 50 chars of first user message
  const preview = firstUserTurn.content.slice(0, 50);
  return preview.length < firstUserTurn.content.length ? `${preview}...` : preview;
}
