import type { Transcript, ConversationTurn } from "./types.js";

/**
 * Convert a transcript to Notion-flavored markdown
 */
export function convertToNotionMarkdown(transcript: Transcript): string {
  const parts: string[] = [];

  // Add summary placeholder - this will be generated by the AI
  parts.push("## Summary\n");
  parts.push("<!-- Summary will be generated by Claude -->\n");
  parts.push("---\n");

  // Convert each turn
  for (const turn of transcript.turns) {
    parts.push(formatTurn(turn));
    parts.push("\n---\n");
  }

  return parts.join("\n");
}

/**
 * Format a single conversation turn
 */
function formatTurn(turn: ConversationTurn): string {
  const header = turn.role === "user" ? "### User" : "### Assistant";
  const content = formatContent(turn.content);

  return `${header}\n\n${content}`;
}

/**
 * Format content, preserving code blocks and adding proper formatting
 */
function formatContent(content: string): string {
  // Split content by code blocks to preserve them
  const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
  let result = content;

  // Ensure code blocks have language hints where possible
  result = result.replace(codeBlockRegex, (match, lang, code) => {
    const language = lang || inferLanguage(code);
    return `\`\`\`${language}\n${code}\`\`\``;
  });

  return result;
}

/**
 * Try to infer the programming language from code content
 */
function inferLanguage(code: string): string {
  const trimmed = code.trim();

  if (trimmed.startsWith("import ") || trimmed.startsWith("export ")) {
    return trimmed.includes(": ") ? "typescript" : "javascript";
  }
  if (trimmed.startsWith("def ") || trimmed.startsWith("import ") || trimmed.includes("print(")) {
    return "python";
  }
  if (trimmed.startsWith("{") && trimmed.endsWith("}")) {
    return "json";
  }
  if (trimmed.startsWith("<") && trimmed.endsWith(">")) {
    return "html";
  }
  if (trimmed.startsWith("$") || trimmed.includes("&&") || trimmed.includes("| ")) {
    return "bash";
  }

  return "";
}

/**
 * Parse raw transcript text into structured format
 */
export function parseTranscript(raw: string): Transcript {
  const turns: ConversationTurn[] = [];

  // Simple parsing - split by role markers
  const sections = raw.split(/(?=^(?:User|Assistant|Human|Claude):)/gm);

  for (const section of sections) {
    const trimmed = section.trim();
    if (!trimmed) continue;

    const isUser = /^(User|Human):/i.test(trimmed);
    const isAssistant = /^(Assistant|Claude):/i.test(trimmed);

    if (isUser || isAssistant) {
      const content = trimmed.replace(/^(User|Human|Assistant|Claude):\s*/i, "");
      turns.push({
        role: isUser ? "user" : "assistant",
        content: content.trim(),
      });
    }
  }

  return { turns };
}

/**
 * Generate a title from the transcript content
 */
export function generateTitle(transcript: Transcript): string {
  const firstUserTurn = transcript.turns.find((t) => t.role === "user");
  if (!firstUserTurn) return "Untitled Conversation";

  // Take first 50 chars of first user message
  const preview = firstUserTurn.content.slice(0, 50);
  return preview.length < firstUserTurn.content.length ? `${preview}...` : preview;
}
